{"./":{"url":"./","title":"Introduction","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 本仓库介绍 Repository Language Description 本仓库介绍 本网站和仓库由阮中楠建立并维护。 Repository Language Description "},"1.基本定义（必看）/1.基本定义（必看）.html":{"url":"1.基本定义（必看）/1.基本定义（必看）.html","title":"1.基本定义（必看）","keywords":"","body":""},"1.基本定义（必看）/1.1.作用域.html":{"url":"1.基本定义（必看）/1.1.作用域.html","title":"1.1.作用域","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 定义 特点 特殊情况 概念 定义 作用域：就是指插件的 作用范围 。不同作用域的插件，互不干扰。 特点 1.rmmv游戏分为三种界面类型：战斗、地图、菜单。 插件不会在超出作用范围外的情况工作。 2.插件分为以下类别： 特殊情况 许多插件都有不同的作用域，不同作用域的插件相互独立。 但是有些插件，可以同时在战斗、地图中使用，这里单独分成了（战斗+地图）的类别。 "},"1.基本定义（必看）/1.2.兼容性.html":{"url":"1.基本定义（必看）/1.2.兼容性.html","title":"1.2.兼容性","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 定义 特点 插件扩展 定义 特点 关于不同作者的插件 Mog自身插件版本组兼容情况（插件示例1.60 – 2.00的旧版本） 已知冲突插件 概念 定义 兼容性：是指两个插件之间的关系，具体兼容性见下列关系。 1）冲突 冲突是指插件A直接干扰/破坏了插件B的结构，造成系统报错。使得游戏无法运行。冲突并不是刻意造成的，有时候是插件作者没有考虑到特殊的情况。 2）强占资源 强占资源是指，插件A强占了插件B需要的系统资源，虽然系统不报错，且能正常运行，但是插件B的部分功能会失效。一般换换插件顺序，能够解决这类情况。 3）相互独立 两个插件各自要各自的系统资源，即使是相同的系统资源，也会排队等待，相互不干扰，这样就说明插件之间相互独立。 4）依赖 依赖表示插件A必须要插件B给予的资源才能运行。 详细可见后面章节基于。 5）不完全依赖 不完全依赖表示插件A在有插件B的情况下，使用计划1；如果没有插件B，那么使用计划2。这样插件通常可以独立运行。但是计划1的功能效果肯定比计划2的要好。 详细可见后面章节作用于、被扩展。 特点 你的游戏中通常情况下会放置大量的插件，虽然大部分插件相互独立，但是也会遇到小概率冲突的情况。因为你每加入一个新插件时，相同作用域下的插件都会相互影响。 另外，你不能给游戏装上两个相同的插件，这是必然 冲突/强占资源 的。 插件扩展 定义 基于：如果插件A必须要插件B给予的资源才能运行，那么就称插件A基于插件B。 所有drill插件中，都加入了校验机制，如果所基于的插件缺失，会弹出相应提示，所以不需要担心游戏时会因缺插件而报错。 作用于/可作用于：根据下图的箭头关系，插件A作用于插件B。箭头是可断开的。 被扩展/可被扩展：根据下图的箭头关系，插件B被插件A扩展。箭头是可断开的。 与”基于”的定义不同，这两个关系属于不完全依赖。插件中经常出现这种扩展关系。 特点 插件有 基于、被扩展 关系的，比较容易出现不同版本插件的 冲突。 比如下图中插件A[v1.2]向插件B[v1.0]寻求资源时，由于旧插件可能没有新的资源提供，造成插件A出错。解决这类问题，只要保证插件都是示例中最新的版本，就可以了。 （但要注意，一次性升级所有插件，还是存在一些风险的，升级时要备份工程。） 关于不同作者的插件 不同作者之间，冲突的隐患非常大。 因为不同作者的写脚本时，考虑的方向完全不同。如果插件的某些地方作硬性设定，将直接影响到其他作者对脚本进行扩展。 Mog自身插件版本组兼容情况（插件示例1.60 – 2.00的旧版本） Mog大部分插件可以单独运行，但是 插件组合后 会对版本比较敏感，如果与目标插件的版本太高或太低，会报错误。 当前已知的版本组如下：（你其实只要按最新的版本来替换 组中所有插件就可以了） 插件 旧版本组1 旧版本组2 最新版本组 MOG_ATB 即时战斗模式 MOG_BattleHud 角色窗口 MOG_BattleCommands 技能类型面板 MOG_BalloonActionName 招式名气泡框 MOG_ConsecutiveBattles 车轮战 MOG_BattlerMotion 技能动作+呼吸效果 MOG_HPGauge 生命浮动框 MOG_EmergeMotion 敌人出现动画效果 无 （v3.5） （v1.0） （v1.5） 无 （v1.6） （v1.2） 无 （v0.1 Beta） （v4.0） （v1.2） （v1.7） （v1.0） （v1.8） （v1.3） （v1.2） （v0.3 Beta） （v4.0） （v1.2） （v1.7） （v1.1） （v2.0） （v1.3） （v1.4） 如果你用了表中高版本组的插件，需要都换成组中高版本的插件，因为两组之间存在不兼容情况。（如果你使用了插件组中以外的版本，兼容情况就未知了。） 已知冲突插件 下列有一些已知会产生冲突的插件，你需要对其做出选择，进行取舍。 MOG_SceneItem.js 全自定义物品界面 MiniInformationWindow.js 详细信息窗口 YEP_ItemCore.js yep物品核心 MOG_BattleResult.js 战斗结果 YEP_VictoryAftermath.js yep战斗结算 MOG_ATB.js 即时战斗模式MOG_SkipWindowLog.js 去掉窗口提示消息 Drill_WindowLog.js 窗口提示消息 YEP_BattleEngineCore.js yep战斗核心 Drill_SenceShop 全自定义商店界面 YEP_ShopMenuCore Yep商店核心 "},"1.基本定义（必看）/1.3.动画帧.html":{"url":"1.基本定义（必看）/1.3.动画帧.html","title":"1.3.动画帧","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 定义 动画帧 并行事件 概念 定义 动画帧：界面中的最小时间单位。1秒=60帧。 帧刷新：脚本中，每帧都会update刷新一次，这种过程称为帧刷新。 帧数（FPS）：在游戏过程中，并不是每秒真的会完美刷新60次，每秒实际的刷新的帧数称为FPS。 动画帧 1）动画帧与FPS rmmv游戏基于动画帧，每帧对 当前界面 进行一次计算，变化游戏内的图形，1秒计算60次。 在游戏中按F2可以看到当前游戏 帧数（FPS）。 2）动画帧与界面 如果当前处于菜单界面，则战斗界面、地图界面都不做任何计算。因此这些界面处于暂停状态。 3）动画帧与游戏时间 游戏时间分为两种，一种是游戏内时间，一种是真实时间。 真实时间是根据计算机系统时间来决定的，与动画帧没有关系。 （可以参见脚本SceneManager._currentTime的定义。） 4）动画帧与变速齿轮 变速齿轮的原理，在于游戏请求时，系统每次都给一个欺骗的时间。 因为游戏1秒需要计算60次，则每1/60秒执行一次计算。 如果系统每1/30秒给游戏一次时间，则游戏变成了2秒才能计算60次。 游戏里的1秒 = 现实的2秒。所以游戏速度变慢了。 （这里的 变速齿轮插件 只改变动画帧时间，不会影响 真实游戏时间 的统计。） 并行事件 并行事件的所有动作，如果没有设置等待帧，那么将默认视为1秒执行60次。 这也是并行事件拖慢游戏速度最大的原因，频繁地执行大量与时间没有关系的重复计算。 因此，当你建立一个并行事件时，请务必优先考虑添加等待帧。 等待1帧 = 1秒执行30次，等待2帧 = 1秒执行20次，等待3帧 = 1秒执行15次 公式为： 计算次数 = 60/ ( 等待帧 + 1 ) 自动执行 与 并行事件的原理一样。 但是自动执行会阻塞你的其他事件动作。如果出现了bug，你会一直动不了，有助于发现问题。而并行事件没有直观的影响，所以需要时刻注意。 "},"1.基本定义（必看）/1.4.显示与透明度.html":{"url":"1.基本定义（必看）/1.4.显示与透明度.html","title":"1.4.显示与透明度","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 定义 常见坑 关系 Rmmv功能 行走图操作 图片操作 插件 自定义照明 - 黑暗层 显现动作/消失动作 倒影镜像/同步镜像 小结 概述 定义 透明度/不透明度：在rmmv中，”不透明度”和”透明度”的意思一样。只要有“透明度”三个字，就都是统一的：255完全不透明，0完全透明。 （从脚本层面上，”不透明度”的英文为opacity，但是用中文解释非常绕，索性全部理解为”透明度”。） 常见坑 当你操作任何贴图时，都会遇到两种操作方法： 显示/不显示， 透明度255/透明度0。 道理简单，但坑就在于： 不显示是看不见图片的， 透明度0也是看不见图片的， 显示的透明度0也是看不见图片的， 不显示的透明度255也是看不见图片的， 不显示的透明度0更加是看不见图片的。 只要看不见图片，就很容易误认为没有生效。所以你必须留意显示与透明度的关系。 关系 显示、透明度与看见关系如下表： 显示 不显示 透明度0 看不见 看不见 透明度40 几乎看不见 看不见 透明度215 能看见 看不见 透明度255 能看见 看不见 另外，看不见也可能包含其他因素，具体情况需要具体分析： 1.空图片，也是看不见的。 2.直接给透明图片，也是看不见的。 3.图片超出了窗口范围，也是看不见的。 Rmmv功能 行走图操作 下图为移动路线中控制的三种情况，透明状态对应 显示/不显示： 玩家的 显示/不显示 可以直接修改，也可以在移动路线中修改： 图片操作 图片的功能比行走图要好理解，图片的 显示/不显示 直接对应下面两条指令。 你必须点开显示才能控制透明度，而不是并列控制的。 插件 自定义照明 - 黑暗层 Drill_LayerIllumination 地图 - 自定义照明效果 自定义照明是在地图的基础上加上一层黑暗层。把上面的表挪用下来，你会发现： 开启 关闭 黑暗层透明度0 看不见黑暗 看不见黑暗 黑暗层透明度40 几乎看不见黑暗 看不见黑暗 黑暗层透明度215 能看见黑暗 看不见黑暗 黑暗层透明度255 能看见黑暗 看不见黑暗 黑暗层的开关（显示/不显示）在这里是以地图为准的，一张地图一个开关。默认启用是一次性对所有地图的，而备注是一对一的。也就是说，如果默认是关闭的，你需要加地图备注来开启黑暗层，不然就看不见黑暗。 显现动作/消失动作 Drill_EventFadeOutEffect 行走图 – 消失动作效果 Drill_EventFadeInEffect 行走图 – 显现动作效果 Drill_PictureFadeOutEffect 图片 – 消失动作效果 Drill_PictureFadeInEffect 图片 – 显现动作效果 显现动作固定为：从 完全透明 到 完全不透明 的过程。动作结束后，对象的透明度将变为255。 消失动作固定为：从 完全不透明 到 完全透明 的过程。动作结束后，对象的透明度将变为0。 这类插件只控制对象的透明度，并不控制 显示/不显示。如果你让某个事件播放动作，事件没有透明过程直接消失了，那么可以确定是其他插件造成的问题，而不是该插件。 倒影镜像/同步镜像 Drill_LayerReverseReflection 行走图 - 图块倒影镜像 Drill_LayerSynchronizedReflection 行走图 - 图块同步镜像 镜像分为 镜面和镜像。镜面是 显示/不显示 的一个重要因素，如果没有镜面，镜像当然不会存在。每张地图会有默认的镜面，你也可以配置自己画的镜面资源图片。 镜像中还有个概念，\"镜像透明同步\"。是指： 镜像透明度 随着 事件透明度 变化而变化。 镜像透明状态 随着 事件透明状态 变化而变化。 也就是说，如果关闭透明同步，镜像和事件贴图的两个属性（显示/不显示 和 透明度）会单独作用。单独作用时，关系如下： 显示/不显示 控制 透明度 控制 镜像 处于无镜面区/处于镜面区 不反射镜像/开启反射镜像 无 事件贴图 事件透明状态 事件透明度 关闭同步后，你可以设置 透明度为0 或 开启透明状态 的事件，使得事件具有镜像却看不见本体。 需要注意的是，你不能修改镜像的透明度。 小结 上述的插件介绍，只是对于部分具体插件的解析。其它的插件也具有相似的功能，不过称呼命名方式会有部分区别。所以这里只能是抛砖引玉，让你留意部分小坑。 在你使用插件时，建议下意识地去分析：是不是开关没开、是不是透明度没有255，另外，考虑一下是不是图片之间相互遮挡了，图片是不是超出窗口范围看不见。 "},"1.基本定义（必看）/1.5.游戏运行原理.html":{"url":"1.基本定义（必看）/1.5.游戏运行原理.html","title":"1.5.游戏运行原理","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 程序入口 运行环境 运行原理 程序入口 Rmmv游戏本质上就是网页游戏。 游戏的一切入口都是从index.html进入的。 工程文件下的入口 部署后的入口（在www文件夹下） ![C:\\Users\\lenovo\\AppData\\Roaming\\Tencent\\Users\\1355126171\\QQ\\WinTemp\\RichOle\\UUAK~D_`14~JES~477TI4E.png 运行环境 Nwjs仅仅是个游戏环境启动器，换成别的环境，一样可以启动游戏。 比如谷歌浏览器、火狐浏览器。 具体可以见链接，其中都有使用说明。 链接：https://pan.baidu.com/s/1HVUxMXaGuZA0nf8fSZUZng 提取码：rm0p （作者我自己用c++封装了一个网页启动器，也可以成功运行rmmv，但是特别卡……理解意义上玩玩就好了） 在手机上安卓打包也是相当于在手机上建立一个安卓启动器，但是具体作者我并没有试过安卓打包，所以暂时不能提供手机端打包方面的建议。 "},"1.基本定义（必看）/1.6.界面.html":{"url":"1.基本定义（必看）/1.6.界面.html","title":"1.6.界面","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 定义 特点 类型 菜单（菜单界面） 战斗（战斗界面） 地图（地图界面） 界面 作用域 游戏界面 界面理解误区 概念 定义 界面：是指用户 当前看到 的游戏窗口内的所有图像画面。 特点 1.界面在脚本中定义为Scene。 2.rmmv游戏分为三种界面类型：战斗、地图、菜单。 （战斗界面和地图界面内容复杂，通过大量游戏数据拼接而成；而菜单界面内容简单，但是数量特别多，是一套大卡组。） 3.系统每次只能运行一个界面，运行时其它界面处于暂停状态。 （系统每次只能运行一张卡片，且每张卡片是单独运行的，不会牵连其他卡片。） 类型 菜单（菜单界面） 菜单界面定制化较强。主要结构如下： 底图：可以被主菜单相关装饰插件进行装饰。 功能部件：原始的rmmv主菜单的部件结构如下图。（由 3个窗口 组成）rmmv本体没有定制菜单的渠道，所有可定制的菜单，都是通过插件一个个配置的。 菜单界面的层级如下：（蓝色部分为多层背景、粒子、魔法圈插件的装饰插入层） 战斗（战斗界面） 战斗界面数据内容较多，但整体结构变化不大。 rmmv本体可以设置 敌人、敌群、回合事件 等，你也可以通过插件定制更多内容。 战斗界面的层级如下： （蓝色部分为多层背景、粒子、魔法圈插件的插入层，其实你并不需要记住所有复杂的层级，你只需要把内容放在想放的位置即可） 地图（地图界面） 地图界面是一种变化性非常强的界面。 切换地图时，地图界面并没有切换，而是进行了游戏数据重读、贴图重组。每个变量、独立开关都直接影响下次地图界面的内容。 rmmv本体可以设置 事件、独立开关 等，你也可以通过插件定制更多内容。 地图界面的层级如下： （蓝色部分为多层背景、粒子、魔法圈插件的插入层，其实你并不需要记住所有复杂的层级，你只需要把内容放在想放的位置即可） 界面 作用域 界面的作用域根据情况分成下面的类： 游戏界面 游戏界面不外乎就这三种基本元素：战斗、地图、菜单。 一些比较新颖的游戏可能会将元素两两融合： 战斗+地图、菜单 （即时战斗游戏ARPG） 战斗、地图+菜单 （策略类游戏） 战斗+菜单、地图 （文字冒险类游戏galgame） 从脚本层面来看，分离战斗与地图，最显著的作用就是节省计算量。 战斗占计算量多，地图占内存大。如果是即时战斗，由于图像变化多，消耗量大，现在的电脑基本不存在问题，但是手机就是一种挑战了。 当你打开菜单时，因为其它界面是暂停状态，所以繁忙计算中的CPU可以瞬间降下来。这也是为什么卡顿的游戏地图中，只要一打开菜单，瞬间变流畅的原因。 另外，如果一个游戏连菜单都卡顿的话，那就真的是电脑硬件的问题了。 界面理解误区 战斗界面、地图界面、菜单界面是三个完全独立的界面，进入了任何一个界面，其他界面都是暂停状态。暂停状态时，数据无法实时交互。 在地图界面中选择菜单时，许多萌新会误以为是在地图界面中添加了菜单，而实际上，这里已经离开了地图界面。地图的轮廓只是一个地图截屏放在了菜单的背景中而已。 "},"1.基本定义（必看）/1.7.贴图.html":{"url":"1.基本定义（必看）/1.7.贴图.html","title":"1.7.贴图","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 定义 特点 概念 定义 贴图：是指用户在 界面 中看到的任何 单一 的图像/图片资源。 特点 1.在脚本定义中为Sprite。 也有称呼sprite为 精灵、容器 等，你只要了解这个名词即可。 2.窗口、图片、文字都是贴图，但一般称呼的贴图都指图片。 3.贴图中可以添加贴图，层层嵌套，形成各种互动元素。 "},"2.性能测试报告/2.性能测试报告.html":{"url":"2.性能测试报告/2.性能测试报告.html","title":"2.性能测试报告","keywords":"","body":""},"2.性能测试报告/2.1.关于插件性能.html":{"url":"2.性能测试报告/2.1.关于插件性能.html","title":"2.1.关于插件性能","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 概念介绍 名词索引 快速区分 思维导图 概念 硬件与软件 电脑硬件性能 硬件内存 插件性能 详解 图形处理 帧数 其他相关 变速齿轮 并行事件与插件 切换菜单时掉帧现象 贴图处理的性能 概述 概念介绍 插件性能：指在游戏中，用来衡量插件所消耗的运行速度的量。 插件性能被定为4个等级：无消耗、低消耗、中消耗、高消耗。 插件性能单位：指在游戏中每20秒（20000ms）执行特定插件时所占用的响应时间。 20秒是作者我在性能测试时固定的测试时间。根据统一的20秒时间，可以判断一个插件的消耗程度。 响应时间 插件性能 0.00ms - 40.00ms 几乎无消耗 40.00ms - 80.00ms 低消耗 80.00ms - 120.00ms 中消耗 120.00ms以上 高消耗 虽然有部分插件可以起到优化性能作用，但是插件加的越多，性能消耗会越来越大。 名词索引 以下你可以按住ctrl键点击下面的词，可以直接定位到想了解的名词： 基本概念 硬件 软件 硬件性能 软件性能 响应时间 性能测试 硬件性能测试 软件性能测试 内存 插件 插件性能 插件性能单位 图形处理 像素 图形 图形处理 帧数 掉帧 其他 贴图处理 快速区分 要查看哪些插件是低、中、高消耗的插件，去看看” 性能测试统计表.xlsx”。 后面会介绍一大堆概念，可能会比较难理解。这里先说结论： 1.如果你的游戏考虑手机端，低消耗流畅运行，你需要： a.确保每张地图的事件 \\ b.确保单次插件指令执行数量 \\ c.少用或者不用 中等消耗 或 高消耗 的插件。 d.并行事件尽可能 \\ 2.如果你的游戏考虑PC电脑端，但是低配电脑也要流畅运行，你需要： a.确保每张地图的事件 \\ b.确保单次插件指令执行数量 \\ c.少用或者不用 高消耗 的插件。 3.如果你的游戏几乎不考虑性能，在较高配置的游戏本中运行，以上问题你全部不需要担心，直接肝就是了。 思维导图 插件性能的思维导图如下：（调整一下word右下角的缩放率，可以看清小字） 概念 硬件与软件 硬件：是电子设备的统称，包括计算机、机械、光学控件等。 软件：是计算机数据和指令的集合，包括应用程序、游戏、系统等，数据也属于软件，不过我们通常称的软件都是应用程序。 硬件性能：硬件的配置决定了性能的上限，高配电脑的性能好，低配电脑的性能差。 要查看硬件性能，可以进入设备管理器，或者进入控制面板查看系统。 图中是测试插件性能时用的低配电脑╭(°A°`)╮。 （该电脑跑不动吃鸡，大型3d游戏都带不动，只能玩一些中低端的3d游戏。然而，该电脑却出人意料地能流畅运行英雄联盟，这令我有些敬佩。） 软件性能：是指软件在能完成某个功能的前提下，速度快不快的能力。 能够完成功能，且速度又快，就说明软件的性能好，反之性能不好。 响应时间：是指软件完成某个功能所消耗的时间。 通过比较 相同功能软件 的响应时间，可以评估出该软件的软件性能。 需要注意的是，响应时间 是软件和硬件共同的结果，同样的插件，在低配电脑消耗为20.23ms，而在高配电脑的消耗为9.14ms。所以，要评估一个软件，必须要统一性能测试的环境。 图中是使用火狐浏览器的检测工具测出的插件 响应时间╭(°A°`)╮。 电脑硬件性能 硬件性能测试：是指对硬件真实物理意义上的性能测试，比如耐热性、防水性、抗压性、抗震性、电磁兼容性，另外还包括对工作期间的运行速度、稳定性、极限负荷运行下的能力等。 专业的硬件性能测试流程非常复杂，我们一般人也很少接触这些专业性太强的知识。不过，这里有一个简单易懂的做法：跑分。 低配电脑跑分： 相比于专业硬件性能测试，跑分只能算其中的小小一环，但是对于我们来说，知道一个分数就足够了，通过比较，就能知道自己的电脑是好是坏。 下图为 低配电脑 的鲁大师跑分：（综合分数为48456） 下图为 低配电脑 的3dmark跑分：（综合分数为571） （结果在3dmark可查： https://www.3dmark.com/3dm11/13658378 ） 中配电脑跑分： 另外，介绍一下标准游戏本的分数：（2018年的新本，7000左右软妹币） 下图为 中配电脑（游戏本） 的鲁大师跑分：（综合分数为201441） 下图为 中配电脑（游戏本） 的3dmark跑分：（综合分数为5559） （结果在3dmark可查： https://www.3dmark.com/3dm11/13658876 ） 高配电脑跑分： 没有。W(ﾟДﾟ)w我穷。 硬件内存 内存：是指软件在系统中占用的空间。软件每次需要临时使用新数据时，都会向内存请求开辟空间放数据以供随时使用。 打开win10的任务管理器（快捷键 Ctrl + Shift + Esc），可以看到所有程序的CPU和内存的关系。 内存属于瞬间爆炸型，系统的内存空间不够了，软件继续如果要求内存，会直接软件停止工作或死机。 相对而言，性能和内存的关系并不紧密，但是内存小了，肯定会影响性能和速度。作者我这里进行测试时，只关注插件的性能占用情况，插件请求的内存空间不在考虑内。 如果你是低配电脑，最好将其他的大软件关闭，这样可以确保游戏运行时不会被抢内存资源。 插件性能 详解 软件性能测试：是指通过模拟一些极端场景，对具体软件的功能进行测试，判断其软件性能与边界，以及在极限性能边界上软件的运行状态。一般包括 负载测试、响应时间测试（速度测试）、压力测试（浪涌测试）三种。 1）负载测试，就是在开了一大堆大软件的同时，测试插件的性能。这个用不上，因为rmmv游戏遇到大软件抢资源时，会自己突然去世，闪退。 2）压力测试，又称浪涌测试，即使用一个超级触发装置，对插件的指定功能，在极短时间内触发执行100000次。这个也用不上，因为我的电脑受不了。 3）响应时间测试，又称速度测试，这个最简单，在执行时多次记录响应时间，统计后取平均值就可以了。 作者我经过响应时间测试后，将所有时间数据通过统一的表列出来（见”性能测试统计表.xlsx”），哪些插件的性能消耗如何，通过列表数据便能一目了然。 插件性能：指在游戏中，用来衡量插件所消耗的运行速度的量。 插件性能分为4个等级：无消耗、低消耗、中消耗、高消耗。 大多数插件都 几乎无消耗，并且不再特定的条件下，这些插件都是不工作的，所以rmmv加800个以上的低消耗插件，都不会造成游戏进不去、卡死的情况。 另外，高消耗没有上限，一个插件如果拥有直接让整个电脑死机的消耗能力，那也只算高消耗插件。因为消耗能力超出一定的范围后，更多不稳定性的问题都会加大这个插件消耗能力，从而消耗爆炸。 毕竟软件的优化性能能力有限，部分功能一定吃大量电脑性能，我们是拦不住的。 插件性能单位：指在游戏中每20秒（20000ms）执行特定插件时所占用的响应时间。 20秒是作者我在性能测试时固定的测试时间。根据统一的20秒时间，可以判断一个插件的消耗程度。 理论上来说，插件数量足够多的时候，20000ms可以被填满，使得电脑变为满负荷工作，这个时候，游戏是会直接卡死的（100%CPU，程序写了死循环那种卡死）。不过一般都到不了那种情况，因为插件工作的范围都有限，多数情况下插件都是不工作的。 性能测试方法： 由于的插件特别多，有许多插件计算量大，混杂在里面难以被发现。 单独关掉一个插件，也看不出明显的卡顿，所以必须通过内存工具来找。 打开火狐浏览器，按F12，点击性能选项卡，即可开始测试性能了。 图中，Drill_SecretCode插件在执行updateInput函数时，耗时20.23ms，正常消耗。 而部分插件，能够明显看到高消耗，比如下图的MOG_Scrollbar插件，执行updateButton却占用了148.55ms：（该插件已被推翻并优化） 参照下面的20000.00ms检测条件的对照表可知，MOG_Scrollbar（菜单滚动条）插件是一个高消耗插件，需要进行算法优化： 响应时间 插件性能 0.00ms - 40.00ms 几乎无消耗 40.00ms - 80.00ms 低消耗 80.00ms - 120.00ms 中消耗 120.00ms以上 高消耗 另外，需要提一下的是，pixi.js也有很高的消耗：142.36ms。 这是因为pixi的函数是底层函数，非常多的插件都在反复使用该函数。所以它的消耗自然是最大的，因为集合了树枝树叶所有的计算量。 你可以点击图中的灰色的三角形，展开看到这个树根函数下面还有哪些其他子函数。由于插件之间有非常多的函数继承关系，所以这个树根下面非常深。 图形处理 像素：是图形的最小基本单位。计算机中所有图形都是由 像素小方格 构成，每个像素包含rgb三个基本颜色值数据属性。部分像素还包括rgba的a透明度数据属性。 图形：是游戏中构成场景的基本单位。与 贴图 的定义相似，但是图形是纯数据体。而贴图是一套封装好的图形处理对象。 比如，一张100x100的图片，是由10000个像素构成的图形。计算机获取到图形后，要将这10000个像素全部渲染到计算机的显示屏上。 假设每个像素存的是rgb三个颜色值，每个颜色值占1个字节（1B），那么100x100的图像字节就占100x100x3x1 = 30KB的字节，这只是100x100的小图，如果是1000x1000的图片，就是3MB。而一般的游戏，少说也要同时绘制200张图片（地图里放一堆事件），那么就接近0.6GB。如果要将所有图片全都渲染到屏幕上，可想而知，图形处理的性能消耗量是多么庞大。 图形处理：也称图像处理，是指将图形最终渲染到电脑屏幕上的过程。通过使用数学算法将二维或三维图形进行转化处理，生成最终的计算机图形画面。 之所以需要提到图形处理，是因为这个部分的 性能消耗 是真的太庞大了，大半性能都用来渲染图形。为此还有一门专业学科，叫计算机图形学。 软件条件下做图形处理计算量太庞大了，那么有没有专门解决图形计算的硬件呢？当然有啦。 图形处理器：也称GPU、显卡，是一个专门用来做图像和图形相关运算工作的微处理器。 我们经常说的n卡（nVIDIA）和a卡（AMD）就是图形处理器硬件。 有趣的是，GPU有芯片级别的硬件： ![C:\\Users\\lenovo\\AppData\\Roaming\\Tencent\\Users\\1355126171\\QQ\\WinTemp\\RichOle\\EHL`ZH[~1C64E%[3[$Q93.png](media/f91f55a7ddefb0c3210bd4be4e668203.png) 也有煤气灶级别的硬件（误）： 具体显卡是如何工作，怎样选择显卡能够加强游戏性，你可以百度查查，或者去问问显卡大佬哦。 中央处理器：也称CPU，是计算机系统的运算和控制核心，也是信息处理、程序运行的最终执行单元。 相对于GPU处理图形，CPU是真正进行主要运算的核心，好的CPU能够极大地提升电脑的硬件性能。插件中的非贴图功能，都是通过CPU来运行计算的。 帧数 帧数：即每秒传输帧数（Frames Per Second），也称刷新率。是图形处理领域的标准定义。每秒钟帧数越多，所显示的图形动作就会越流畅。一般标准为60帧。 在游戏中 按F2 可以调出检测帧数变化窗口。 掉帧：即 图形处理 自我优化并对帧数进行减少后的现象。掉帧是以减少图形渲染为代价，而增加 主程序计算时间 的一种方法。掉帧是正常现象。 以下是个人总结的FPS观感与体验： 效果 帧数 感受 50~60 完美运行 40~50 稳定运行 30~40 流畅运行 26~30 轻微卡顿 22~26 掉帧严重 20~22 卡成狗 18~20 卡成翔 15~18 卡成PPT 15以下 游戏没法玩了 如果帧数一直在30帧以上，还是比较靠谱的，人眼在30帧与60帧之间的感受差距不大。 然而只要帧数低于30帧，游戏时就能逐步感受到部分卡顿，对于玩家来说，极可能会影响游戏体验。 在加载界面中，帧数可能会突然掉很多，这是因为加载时要初始化大量数据，分配内存，属于正常现象，加载完毕后会恢复稳定帧数。 其他相关 变速齿轮 变速齿轮，是另一个特殊的性能影响因素。 之前提到的 硬件、内存、图形处理 都在各个方面影响性能，而变速齿轮能够直接强制改变帧数，设置的速度越快，性能消耗越大，并且是爆炸式上升。 （高配电脑都能卡成2帧……） 并行事件与插件 值得一提的是，并行事件 与 持续执行的插件 在功能上是等效的。 但不同的是，插件由于是独立出去的脚本模块，可以进行性能监听或算法优化。 而并行事件基于纯事件的设置，执行次数不可把控，在优化性能上存在明显劣势。如果你会js脚本，最好自己写相关插件去实现。 切换菜单时掉帧现象 文档”界面.docx”中有介绍。切换界面后，上一个界面所有数据任务处于暂停状态。所有计算量都转移到下一个界面的刷新。 切换菜单掉帧属于正常现象。切换掉帧后，会恢复平稳状态。 从脚本层面上看，每个界面都是一个相对独立的图形处理系统，界面切换之后，原界面的所有图形的工作和内存都会被释放。而进入新的界面后，所有图形需要重新构建，这也就造成了帧数骤降。 这种重建现象非常常见，所有游戏都需要重建。 只是不同的游戏重建的时间非常长，以3d游戏为例，为了初始化3d贴图资源，通常会让用户进入一个非常长的载入界面。Rmmv为2d，所以不需要担心出现长时间重建。 贴图处理的性能 贴图处理：在作者我的插件测试说明中，你会发现部分插件的时间复杂度有 ”o(贴图处理)” 参数。 贴图处理是最难评估插件性能的一个参数。下面因素会影响性能： 1.插件对贴图进行平移、变换、缩放等控制的计算量。可能为o(n) ~ o(n\\^2) 2.图像投射显示的面积。可能为o(n) ~ o(n\\^2) 3.图像刷新的频率。可能为o(1) ~ o(n\\^3) 上面的因素叠加到一起，你会发现，与事件毫不相干的插件，只因为有贴图处理这一项，而造成很大的波动。在50个事件、100事件、200个事件的情况下，插件消耗截然不同，既不是一般线性关系，也不是单纯的指数关系。 作者推测，这里可能有两个原因，一是计算机计算量(CPU)有限，大量事件的计算挤兑了资源分配，其他插件的需要更多时间等待资源分配。二是图形显示计算(GPU)有限，图片越多，GPU的显示控制的负担就越大。 介于之前提及的 图形处理 和 掉帧 可知，贴图处理的计算量是一个不稳定的量，而真实游戏中很容易执行各种不同情况的变化，所以这里我们会将事件的数量作为一个特殊的条件，进行多次测试。 "},"3.系统/3.系统.html":{"url":"3.系统/3.系统.html","title":"3.系统","keywords":"","body":""},"3.系统/3.1.关于GIF动画序列核心.html":{"url":"3.系统/3.1.关于GIF动画序列核心.html","title":"3.1.关于GIF动画序列核心","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 插件介绍 名词索引 子插件文档 插件关系 思维导图 动画序列 定义 状态元 状态元设置 动作元 资源设置 从零开始设计 直接配置 - 循环GIF 直接配置 - 单次播放GIF 直接配置 - 完整动画序列 小工具配置 - 循环GIF 小工具配置 - 单次播放GIF 常见问题 配置的动作元无法播放 概述 插件介绍 基础插件： ◆Drill_CoreOfActionSequence 系统 - GIF动画序列核心 子插件： ◆Drill_ActorPortraitureExtend 战斗UI - 高级角色肖像 ◆Drill_PictureActionSequence 图片 - GIF动画序列 ◆Drill_EventActionSequence 行走图 - GIF动画序列 GIF动画序列可将多张png图片组合，可随时播放不同序列。去看看：思维导图 。 该插件含配置小工具： GIF动画序列编辑器（DrillGIFActionSequenceEditor） 你可以直接从零开始设计配置，熟悉插件： 直接配置 - 循环GIF 直接配置 - 单次播放GIF 后期制作动画序列，将会频繁用到小工具： 小工具配置 - 循环GIF 小工具配置 - 单次播放GIF 名词索引 以下你可以按住ctrl键点击下面的词，可以直接定位到想了解的名词： 动画序列 动画序列 底层变换唯一性 状态元 状态元 状态名 状态元集合 动作元 动作元 动作名 优先级 子插件文档 以下 子插件 有相关插件说明文档： 子插件名称 文档名称 小工具：GIF动画序列编辑器（DrillGIFActionSequenceEditor） （工具内）关于GIF动画序列核心编辑器.docx Drill_ActorPortraitureExtend 战斗UI - 高级角色肖像 5.战斗UI > 关于高级角色肖像.docx Drill_EventActionSequence 行走图 - GIF动画序列 7.行走图 > 关于行走图GIF动画序列.docx 插件关系 GIF动画序列核心的插件关系如下图。 思维导图 GIF动画序列核心结构的思维导图如下：（调整一下word右下角的缩放率，可以看清小字） 动画序列 定义 动画序列：动画序列是一个完整的盒子，每个动画序列都包含成批量的GIF切片，即状态元 与 动作元。 动画序列、GIF动画序列、GIF动作序列 是同一个东西，只是称呼不同。 （就目前情况看，live2d动画序列是不可能成功写出插件了，所以只有GIF动画序列了。） 放映动画序列：要操作这个动画序列盒子，需要从外部输入要播放的动作名、状态名、状态名列表。动画序列接收到输入后，按情况播放不同GIF图像。 如果动画序列中没有指定的状态名、动作名，则没有任何效果。 相关名称定义可以去看后面章节的：状态名 、动作名。 底层变换唯一性：脚本上，动画序列 只变换 图片资源（bitmap），其它数据全都不影响（平移xy、中心锚点anchor、缩放拉伸scale等都不变）。 也就是说，动画序列中，不能自定义额外的平移、拉伸等效果，需要与其它动作效果插件组合使用才行。 状态元 状态元：状态元本质上就是一个GIF切片，用于表示 持续执行的状态。 比如 小爱丽丝静止的GIF状态，小爱丽丝行走时的GIF状态。 状态元自循环：如果状态元集合中只有一个状态元，那么这个状态元会单独循环播放。 状态名：即状态元的名称，设计前需要自定义此名称，会作为标识由外部调用。 下图中的”小爱丽丝静止”即为状态名。 状态元集合：用于存放多个状态元的集合，这个集合可以随机播放状态元。 权重：是指状态元被随机抽中的概率。常用的状态元可设置高权重，这样被随机抽中的概率会更大。 状态元设置 默认状态元集合：指动画序列启用后，默认执行的状态元集合。该序列必须配置至少一个状态元，不然在动画序列导入后，你将看不见任何图像。 状态元命名：状态元的名称是完全自定义的。在使用插件指令调用动画序列时，将会直接使用状态元的名称，所以在设计名称时，最好多考虑一下起名方式。 动作元 动作元：动作元本质上也是一个GIF切片，用于表示 临时执行一次的动作。 与状态元不同，动作元激活后，会在状态元集合中插播且只播放一次。 动作名：即动作元的名称，设计前需要自定义此名称，会作为标识由外部调用。下图中的”小爱丽丝攻击”即为动作名。 优先级：优先级低的动作元播放时，可以被后来的优先级高的动作元中断并播放。 优先级低的、优先级相同的 动作元 不会中断当前 动作元。 优先级低的、优先级相同的 动作元 也不会中断当前 状态元。 无法中断的动作元，会被取消。 资源设置 1）资源可大可小 资源的大小没有限制，可以是大的肖像，也可以是小像素行走图。 需要注意的是，所有帧都必须拆成单张图片，才能配置到动画序列。 2）资源帧数不限 GIF动画序列的帧数不限，可以通过动态立绘软件（比如live2d）导出100张以上的图片，然后配置到 动作元或状态元 中。 3）资源名不能重复 如果你是从外面找到的素材，最好将这些素材全部进行 重新命名 ，因为后期这些素材将会全部放在 同一个 文件夹，必须保证这些文件名不会重名，否则会被覆盖。 （下图为东方非想天则的素材示意图……好像不小心截取到了威严满满的抱头蹲防。。） 从零开始设计 你可以先了解 直接配置，再去看看 小工具配置，原理是一样的。 不过注意，后期主要以 小工具配置 为主。 该工具在”插件小工具”文件夹中。 具体用法你可以打开软件，并查看帮助文档：”关于GIF动画序列核心编辑器.docx”。 直接配置 - 循环GIF 1）创建工程 创建一个初始工程，加入两个动画序列插件。 2）复制资源 将用到的资源png图片文件放入 Special__actionSeq 文件夹中。 这里打算配置： 图片GIF-波浪点（20个图片） 3）配置动作序列 进入动画序列插件核心，选择一个动画序列。 配置状态元即可，将20张图片都放入 资源-状态元 列表中。 注意，需要保证 默认状态元集合 与 状态元名称 保持一致。 4）插件指令绑定 配置后，用插件指令将 动画序列10 绑定到 图片8 上，就完成了。 ![C:\\Users\\lenovo\\AppData\\Roaming\\Tencent\\Users\\1355126171\\QQ\\WinTemp\\RichOle\\Y~}_)WM~E%F$4}FFU36_AG.png 图片延迟问题：有时候动画序列在图片建立后，不能立即设置动画序列，不然会使得动画序列找不到对象进行初始化。这时应该等1帧再设置。 直接配置 - 单次播放GIF 1）创建工程 创建一个初始工程，加入两个动画序列插件。 2）复制资源 将用到的资源png图片文件放入 Special__actionSeq 文件夹中。 这里打算配置： 图片GIF-小闪烁（10个图片） 3）配置动作序列 进入动画序列插件核心，选择一个动画序列。 配置一个空的状态元名字为“空图片状态”。 注意，需要保证 默认状态元集合 与 状态元名称 保持一致。 接下来，配置一个动作元，设置名字为“闪烁一次”。 将资源的10个图片，配置到 资源-动作元 列表中。 4）插件指令绑定 建立一个事件，执行显示图片，然后 设置动画序列。最后播放动作。 可以看到，GIF的图片播放了一次后，就消失了。 5）原理说明 动画序列中，必须要有默认状态元集合，必须要有至少一个状态元。 状态元需要作为循环的对象，不停的循环播放GIF。 所以，需要给一个空资源图片的状态元。（可以看看概念 状态元 ） 这时候，再播放一次动作元，动作元播放完毕后，就又回到 空图片 循环的状态元了。 直接配置 - 完整动画序列 1）配置关系 完整的配置就是将上述的两个配置结合起来。 一个动画序列中，可以配置很多 状态元 和 动作元，是一个大的盒子。可见 动画序列 。 你需要将资源填充到盒子中，完成盒子配置后，再通过插件指令控制播放。 2）创建工程 创建一个初始工程，加入两个动画序列插件。 3）复制资源 将用到的资源png图片文件放入 Special__actionSeq 文件夹中。 这里打算配置： 量子妹（8个图片，2个状态元，2个动作元） 3）配置动作序列 进入动画序列插件核心，选择一个动画序列。 配置两个状态元：量子妹静止和 红量子妹静止 默认状态元集合为 量子妹静止 。 配置两个动作元：量子妹受伤 和 红量子妹受伤 注意，配置动作元的帧间隔为25帧，拉长受伤图片的显示时间。 4）插件指令绑定 建立一个事件，执行显示图片，然后 设置动画序列。 可以看到，绑定后，动画序列将按照默认的状态，循环播放。 （默认播放速度4帧，有点快，略显鬼畜） 随后，添加插件指令，可以控制播放受伤动作。 以及修改集合，使其切换至红量子妹版本。 以上是完整的配置与调用方法。 5）直接配置大量资源方法 如果状态元有非常多的图片，一个个配置非常麻烦。（比如从live2d中导出的大量图片） 这里推荐使用小工具 动画序列GIF编辑器，可以进行批量导入。 不过，直接导入也是可以的， 比如下图有45张小爱丽丝图片需要配置。 ![C:\\Users\\lenovo\\AppData\\Roaming\\Tencent\\Users\\1355126171\\QQ\\WinTemp\\RichOle\\]TI)NJ91}USDN}P]G`WTGB.png 先配置一个”小爱丽丝 (1)”后，点击文本。 将文本复制到记事本中，按照下面的格式，一次写2、3、4、5、6……直到45. 逗号必须是英文逗号，引号也必须是英文引号。 ![C:\\Users\\lenovo\\AppData\\Roaming\\Tencent\\Users\\1355126171\\QQ\\WinTemp\\RichOle\\8JT11SMM%$8[UCT}JLDWI3.png 写完后，按Ctrl+A全选，然后复制粘贴到刚才的文本中。 通过这种方式，可以将一堆文件配置上，可以免去一个个点资源图片的麻烦。 ![C:\\Users\\lenovo\\AppData\\Roaming\\Tencent\\Users\\1355126171\\QQ\\WinTemp\\RichOle\\H27$~AGG3SB2W7K%C@YJ.png 小工具配置 - 循环GIF 此配置步骤在小工具的操作教程中也有。 可以看看帮助文档：“关于GIF动画序列核心编辑器.docx”。 1）小工具中导入工程 如果你是第一次使用该工具，先 备份 你的工程，再对备份的工程进行操作。 （你可以用小工具 新建/导入/打开 工程，这里按 导入的流程 走） 进入软件后，点击rmmv交互按钮。 选择一个工程，然后点击“从rmmv中导入数据”。 如果指定的rmmv工程没有加动画序列插件和配置，那么会系统会提示你自动添加新的数据，并走新建的流程。 工程与交互：该编辑器的全部数据将单独存储成一个工程文件(.drillas)，与rmmv的工程(.rpgproject)数据完全不相关，二者是独立存在的。而该工程的数据，能够从rmmv中进行导入，也可将数据导出到rmmv中，这类过程，叫做rmmv交互。 导入 插件示例集合的工程 后，可以看到动画序列数据全部显示了。 2）新建动画序列 选择一个空白区域，准备输入一个新的动画序列。 这里选择的动画序列编号为15。 3）新建状态元 在图中下列输入框填写内容。 动画序列的标签随便起一个名字，并不作用到游戏中。 状态元的名称要留意一下，子插件会作为标识来调用。由于只当成一个GIF，所以这里起名为”固定的GIF”。 4）状态元配置GIF 在下方空白帧区域右键菜单，添加一个GIF。比如编辑器中help文件夹中的”小爱丽丝_示例GIF.gif”文件。（你也可以批量添加图片、序列大图） 添加GIF时，有两种读取器可选择，根据你的情况选择一个。 5）保存工程 保存工程，选择一个文件夹保存为工作空间即可。 需要说明的是，编辑器会自动识别，并帮你填”默认状态元集合”参数。 游戏中会自动根据这个默认集合对GIF动画序列进行初始化。 6）导出配置到rmmv 点击选项栏的rmmv交互按钮。 点击”导出数据到rmmv”，即可将动画序列配置转移到rmmv中。 这里软件会提示你，必须要先关rmmv工程，才能导出。 到这里，编辑器的工作就完成了，接下来我们要进入游戏进行测试配好的GIF。 （注意，img/Special__actionSeq 文件夹的图片资源，会自动覆盖，不需要去管） 上述操作全都在小工具中进行，完全不需要 经过 rmmv的插件编辑器 哦。 7）插件指令绑定 GIF动画序列核心 单独不能使用，所以这里还需要一个 子插件 ： ◆Drill_PictureActionSequence 图片 - GIF动画序列 加了子插件后，建立一个事件，如下：（注意动画序列编号对应15） 8）测试 在游戏中接触这个事件，就可以看到图片显示了。 小工具配置 - 单次播放GIF 1）创建工程 创建一个初始工程，加入两个动画序列插件。 2）小工具中新建工程 注意，这里操作的是 没有动画序列配置 的新工程，所以新建覆盖没问题。 （你可以用小工具 新建/导入/打开 工程，这里按 新建的流程 走） 进入软件后，点击新建。 3）新建动画序列 新建工程后，随便在空白处选择一个动画序列，并命名。 4）新建空白状态元 新建一个状态元，写上名称即可，不需要编辑其他内容。 5）新建动作元 新建一个动作元，命名：闪烁一次。 在下面空白处右键菜单添加 图片/GIF/序列大图，配置动作元。 6）保存工程 保存工程，选择一个文件夹保存为工作空间即可。 7）导出配置到rmmv 点击选项栏的rmmv交互按钮。 点击”导出数据到rmmv”，即可将动画序列配置转移到rmmv中。 这里软件会提示你，必须要先关rmmv工程，才能导出。 到这里，编辑器的工作就完成了，接下来我们要进入游戏进行测试配好的GIF。 （注意，img/Special__actionSeq 文件夹的图片资源，会自动覆盖，不需要去管） 8）插件指令绑定 建立一个事件，执行如下指令：（注意动画序列编号对应1，播放动作元时要对应名称） 9）测试 在游戏中接触这个事件，就可以看到图片显示，并只播放一次动作。 （注意，核心插件v1.3及之前版本，播放结束后会停留在第一帧动作） （此bug在v1.4中被修复） 常见问题 配置的动作元无法播放 问题名称 配置的动作元无法播放 问题图示 无 问题描述 在动画序列中，配置了 量子妹的状态元 和 量子妹的动作元。 进入游戏后，播放动作元没有效果。 原理解析 动画序列核心v1.2及以前版本，设定上存在一些问题， 当 动作元优先级 低于 状态元优先级 时，不会播放该动作元。 也就是说，如果没有任何配置，默认优先级都为0时，会导致动作元无法播放。 解决方案 1）你可以更新核心到v1.3或以上版本，优先级都为0时，可以正常播放动作元。 2）你也可以在配置动作元时，直接设置优先级为1以上。 "},"3.系统/3.10.滤镜效果大家族.html":{"url":"3.系统/3.10.滤镜效果大家族.html","title":"3.10.滤镜效果大家族","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 插件介绍 插件关系 滤镜的定义 滤镜（作用于单张贴图） 滤镜（作用于整体） 滤镜的种类 纯色滤镜 着色滤镜 填充滤镜 模糊滤镜 噪点滤镜 滤镜的变化属性 线性滤镜 波动滤镜 其他说明 性能影响 概述 插件介绍 滤镜的作用范围非常广，它由滤镜核心，派生出许多子插件： ◆Drill_CoreOfFilter 系统 - 滤镜核心 以下是 作用于单张贴图的滤镜 插件： ◆Drill_EnemyFilter 单位 - 滤镜效果 ◆Drill_EventFilter 行走图 - 滤镜效果 ◆Drill_ItemTextFilter UI - 物品+技能文本的滤镜效果 ◆Drill_PictureFilter 图片 - 滤镜效果 ◆Drill_DialogFilter 对话框 - 滤镜效果 ◆Drill_X_BattleHudFilter 战斗UI - 角色窗口的滤镜效果[扩展] ◆Drill_X_GaugeBossFilter UI - 高级BOSS框的滤镜效果[扩展] ◆Drill_X_EventTextFilter 行走图 - 事件漂浮文字的滤镜效果[扩展] 以下是 作用于整体的滤镜 插件： ◆Drill_BattleFilter 战斗 - 滤镜效果 ◆Drill_LayerFilter 地图 - 滤镜效果 ◆Drill_X_LayerColorFilter 地图 - 全图滤色镜[扩展] 插件关系 插件的从属关系如下图： 其中，下面三个插件有相互额外扩展的关系： 需要注意的是，虽然都属于滤镜家族，但是插件里面的插件指令/注释，可能指令和参数的格式有很大区别，注意区分。 滤镜的定义 滤镜（作用于单张贴图） 滤镜，是在资源图片的基础上，对资源图片进行额外处理的模块。 滤镜一般只作用于单张贴图。 需要注意的是，它不会改变资源图片的基本属性，如大小、透明度、图片位置等都不会发生变化。 图中为纯色滤镜。 滤镜的种类有很多，在后面的章节分别有介绍。 滤镜（作用于整体） 滤镜还可以作用于整个游戏界面，或者某个图层下的所有贴图。 由于是对整体添加效果，并且能与单张贴图的滤镜效果叠加，所以消耗性能非常大。下图中测试的电脑帧数稳定在30帧，但是没有开滤镜时，帧数稳定在40帧左右。 作用于整体的滤镜功能也十分受限： 1.地图滤镜只能瞬间切换。 2.没有 波动滤镜 。 3.着色滤镜的程度只有0和255，中间过渡的1-254默认视为255。 从脚本层面，rmmv的核心库pixi提供了基本的下列几种滤镜，它们分别是： 遮罩滤镜（SpriteMaskFilter） 颜色矩阵滤镜（ColorMatrixFilter） 模糊滤镜（BlurFilter） 噪点滤镜（NoiseFilter） 抗锯齿滤镜（FXAAFilter） 置换滤镜（DisplacementFilter） 考虑到实用性关系，插件中的滤镜 与脚本中初始定义的滤镜略有不同。另外，pixi官方还提供了pixi-filter.js库，库中集合了更多其它有趣的滤镜效果，这里暂不考虑。 滤镜的种类 纯色滤镜 纯色滤镜的效果与ps中的正片叠底效果一模一样。 固定分为7种颜色：纯黑、纯蓝、纯绿、纯红、黄色、紫色、青色。 （图中为滤镜程度开到255最大程度的效果） 光的三原色是：红、绿、蓝。 黄=红+绿。紫=红+蓝。青=蓝+绿。 白=红+蓝+绿。黑=什么颜色都没有。 设置滤色镜后，比如纯蓝，图片将只剩下的蓝色光线，因为黄色、紫色、绿色属于混合色，所以效果不太一样。 你需要适当调整透明度，对周围环境滤镜颜色进行微调。 着色滤镜 着色滤镜是在图像色彩信息的基础上，进行额外填色。 分为一下几种：黑白、反色、鲜艳 、漂白、饱和度降低、古墨水画色、古铜色、宝丽来相机色、红绿蓝翻转、夜色、致幻色。常用的一般为前面4种。 反色：反色与红绿蓝翻转不一样，反色是色彩值直接255取差值。而红绿蓝翻转，是红的色彩值给绿色，绿色的色彩值给蓝色，蓝色的色彩值给红色。 （从左至右依次为 原图、反色、红绿蓝翻转） 需要一提的是，反色的实际效果，与ps的反相有出入。可能是由于程序内部的色彩矩阵算法不一样，ps中应该是黑色的部分被填充成了白色，使得反色的效果反而变亮了。 漂白：需要注意的是，漂白并不能使图像变亮，漂白是将整个图像的倾向于白色。与纯色滤镜搭配后，亮度仍然不变。 （从左至右依次为 原图、纯蓝、纯蓝+漂白） 填充滤镜 填充滤镜的效果与ps中的油漆桶填充效果一模一样。 含有8种颜色：纯黑、纯蓝、纯绿、纯红、黄色、紫色、青色、纯白。 并且支持自定义填充颜色（#ffaacc）。 填充滤镜会覆盖图片的所有不透明区域，含有背景的图片会被填充成矩形。 需要注意的是，全填充之后，只能看见影子，反而看不清脸了。 模糊滤镜 模糊滤镜是单独的滤镜，并没有种类划分。 模糊滤镜可以使得图像变的极其模糊。 噪点滤镜 模糊滤镜是单独的滤镜，并没有种类划分。 噪点滤镜会使得图像偏向于电视机花屏的效果。 先后添加的滤镜效果： 这里有一个比较有意思的是，先噪点后模糊，与先模糊后噪点，可以达到不一样的效果。 为了控制先后顺序，这里必须要求等待一帧后再添加，如果同时添加，则只有默认的滤镜顺序。 滤镜的变化属性 滤镜根据程度，这里固定范围为0-255。255的程度最强烈，0的程度为完全关闭滤镜的情况。 线性滤镜 插件指令默认都是线性滤镜，功能为：变化到目标程度后，一直保持滤镜情况。 线性滤镜需要两个参数，即目标程度（0-255）和变化时长（单位帧）。 ![F:\\rpg mv箱\\D_HEO@%`1([~A$9~4I()WA.jpg 波动滤镜 波动滤镜与线性滤镜不一样，由于不存在保持滤镜颜色的时间，所以开启关闭时，波动滤镜都是瞬间切换。 波动滤镜需要两个参数，即范围（0-255）、周期（波动一次所需时间，单位帧） 其他说明 性能影响 滤镜是性能消耗大户，因为带滤镜的图片效果都是通过即时演算形成的。 性能测试中并不能准确找到该插件的消耗量，只能通过update总消耗量相减来进行估算。所以误差会比较大。 具体性能数据你可以去看看”性能测试统计表(滤镜).xlsx”。 "},"3.系统/3.2.关于全局存储.html":{"url":"3.系统/3.2.关于全局存储.html","title":"3.2.关于全局存储","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 相关插件 插件关系 结构 定义 存储文件 关于Meta元素 其他说明 概述 相关插件 以下是与全局存储有关的插件： ◆Drill_GlobalVariable 系统 – 跨存档的变量 ◆Drill_GlobalGameTimer 系统 - 累计游戏计时器 ◆Drill_SceneSelfplateA、B 面板 – 全自定义信息面板A、B ◆Drill_SceneSelfplateC、D 面板 – 全自定义信息面板C、D ◆Drill_SceneSelfplateG、H 面板 – 全自定义信息面板G、H ◆Drill_SceneSelfplateI、J 面板 – 全自定义信息面板I、J ◆Drill_SceneSelfplateK、L 面板 – 全自定义信息面板K、L ◆Drill_SceneSelfplateM、N 面板 – 全自定义信息面板M、N ◆Drill_SceneGalleryA、B 面板 – 全自定义画廊A、B ◆Drill_SceneGalleryC、D 面板 – 全自定义画廊C、D ◆MOG_Music_Book 面板 – 音乐书 ◆Drill_TitleBackground 标题 – 多层标题背景 ◆Drill_TitleCircle 标题 – 多层标题魔法圈 ◆Drill_TitleParticles 标题 – 多层标题粒子 ◆Drill_TitleGif 标题 – 多层标题gif ◆Drill_TitleTiledGif 标题 – 多层标题平铺GIF ◆Drill_TitleVideo 标题 – 多层标题视频 ◆Drill_TitleScene 标题 – 全自定义标题界面 全局存储相关的优化插件： ◆Drill_X_GlobalOptimization 系统 - 全局存储性能优化[扩展] 插件关系 全局存储的插件相互之间 没有 依赖关系，如下图所示： 结构 定义 正常存储：将所有游戏存档保存在固定编号的存档中。新开游戏，所有数据清空。 全局存储：通过插件指令后台存储，将数据存储在全局文件中。新开游戏不会改变已存储的数据。 注意，由于全局存储在一开游戏后，就会立即对全局数据文件进行了读取，从而覆盖初始化数据。所以你在测试游戏调整参数时，可能会遇到参数修改无效的情况。 遇到这种情况，要多留意你测试的插件是否开了全局存储，另外要记得删掉save文件夹下的文件。 存储文件 1）一般全局数据文件 全局数据文件位置：rmmv没有那么深沉隐秘的存储，所有存储的文件都在save文件夹中。（如果是用服务器搭建的云端游戏，则在服务器的save文件夹中。） 你只要把save文件夹中的所有文件清空，那么游戏的所有全局存储和存档都会被清空。 （大部分metagame游戏也是通过这种全局方式存储，不过有的游戏为了完美隐藏，会将全局存储的文件藏在玩家c盘中一些非常隐秘的位置，就像病毒一样，删游戏也无法改变游戏进度。） 2）插件自控制的文件 部分插件可能会有自己控制的全局文件，比如： Drill_GlobalGameTimer 系统 - 累计游戏计时器 计时器插件会专门单独存一个 drill_timer.rpgsave 文件，用来记录玩家累计游戏时间。 关于Meta元素 meta-game（元游戏）：指利用 超出游戏以外的因素 对游戏本身产生影响的游戏。 Meta元素是一种游戏设计思路，通过Meta可以增强玩家的游戏带入感。 游戏在被制作出来时，战斗、剧情、结局等就已经被注定了，这是游戏以内的因素。 而玩家在游戏过程中的反应、情绪，以及在游戏中某些特殊行为，都是游戏以外的因素。 我们可以通过全局存储来设计 游戏以外的影响因素 。 比如，我们可以知道 玩家的游戏时间、玩家在其它存档中的失败经历、玩家在游戏中去过哪些特地地点 等信息（玩家删正常的存档也无法清除这些信息）。 从这个角度上对玩家的行为反映进行逐一设计，能让玩家产生游戏之外的高度上思考：“到底是我在玩游戏，还是游戏在玩我？” 其他说明 全局变量在 测试战斗 时，可能会自己存储global文件，为避免影响，战斗测试前注意清理一下save里面的全部文件。 "},"3.系统/3.3.关于变量数组核心.html":{"url":"3.系统/3.3.关于变量数组核心.html","title":"3.3.关于变量数组核心","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 插件介绍 变量数组 定义 基本操作 其它相关 解谜设计 物体触发插件 概述 插件介绍 核心插件： ◆Drill_CoreOfNumberArray 系统 - 变量数组核心 类似插件： ◆Drill_CoreOfString 系统 - 字符串核心 这类插件用于扩展可以用的数据类型，用法和 变量、开关相似； 可以通过 脚本调用，也可以通过 插件指令调用。 （但到后期，还是建议大家学习一下脚本，底层知识了解越多，设计思路就越明朗） 变量数组 定义 变量数组：指多个变量按顺序划分为一个组的数据结构。 每个数字都有一个索引值对应，通过索引可以找到那个数字。 注意，变量数组 是一维数组，且只能装 整数数字 ，索引从1开始计数。 比如，rmmv的 变量 就是一个大数组。 如下图，数组的最大值为80，也就是说这是一个长度为80的数组。 索引值21，能够获取到 “缓冲变量A” 的值。 由于rmmv变量的数组经常不够用，所以这里使用变量数组，可以节省许多事件开关的写法。 另外，实际编程语言中，数组的定义极为宽泛，包含：二维数组、多维数组、元数组……这里都不考虑，只考虑简单的数组。 索引取值：在指定的数组中，设置索引值，可以通过插件指令获取到相应的变量值。 获取到值后，将把值赋给变量：（如下图，把数组的第1个值，给变量21） 变量数组长度：每个数组都具有自己的长度值，具体根据配置、插件指令而定。 比如，核心中配置了五个数字，则长度值为5。 使用插件指令赋值，并显示，可以看到下图效果： 需要注意的是，如果使用索引获取时，索引值超出了数组长度，则获取到默认的0值。 基本操作 1）遍历数组： 一个标准的遍历写法如下： 用到了3个变量： 缓冲变量A（id 21）： 用于表示当前的索引。 缓冲变量B（id 22）： 用于表示当前数组的长度。 缓冲变量C（id 23）： 用于表示当前取到的数字，取到即用。 数组长度也可以实时获取，这样可以节约一个变量B： 另外，需要注意的是，如果你把事件写在了并行事件中，且有 等待 时间，那么你一定要确保同一时间里，变量ABC不会被其他事件调用，否则会出现赋值错位的情况。 如果你知道数组长度，比如长度为5，且不会变化，那么直接索引赋值就可以，只不过有些费变量： 2）复制/切分数组： 你可以在核心中，准备一个临时数组，与“缓冲变量”的用法一样，只临时使用。 通过复制数组，复制后操作这个临时数组，来进行遍历或其他操作。 3）统计值： 变量数组核心还额外提供了一些查找最大最小值、平均数的方法。 （注意，由于平均数不能存小数，所以计算结果会被四舍五入。） 用法如下： 4）脚本调用： 如果你需要使用一些脚本来调用到数组，可以用下面的指令： 其它相关 解谜设计 解谜设计中，顺序记忆关卡用到了变量数组。 通过变量数组，将关卡的显示顺序存储了起来。 具体可以去看看“解谜设计-顺序记忆.docx”。 物体触发插件 物体触发中，经常会批量获取事件id，这些事件id可以转存到 变量数组中。 下图为通过对话框的方式，显示捕获的事件id。 "},"3.系统/3.4.关于弹道.html":{"url":"3.系统/3.4.关于弹道.html","title":"3.4.关于弹道","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 插件介绍 插件关系 弹道模式 直角坐标模式 极坐标模式 轨道锚点模式 两点式 参数类型 类型 - 速度 类型 - 方向 类型 - 轨道锚点 类型 - 两点式 1. 不移动 2. 瞬间移动 3. 匀速移动 4. 增减速移动 5. 弹性移动 6. 抛物线移动 数学公式 公式关系 可用变量与常量 直接写数字常量 路程计算公式 可用变量与常量 公式：只初速度 公式：初速度+波动量 公式：初速度+波动量+加速度 公式：初速度+波动量+加速度+最大最小 自定义公式 方向计算公式 可用变量与常量 公式：固定方向 公式：四周扩散 公式：扇形范围方向 自定义公式 组合公式效果 抛物线运动 间隔改变方向运动 逆时针圆周运动 概述 插件介绍 核心插件： ◆Drill_CoreOfBallistics 系统 - 弹道核心 子插件： ◆Drill_CoreOfGaugeMeter 系统 - 参数条核心 ◆Drill_CoreOfShatterEffect 系统 - 方块粉碎核心 ◆Drill_CoreOfSelectableButton 系统 - 按钮组核心 ◆Drill_STG__core STG - 引擎 弹道：是指能够描述 单个或一群 粒子/碎片/子弹运动的轨迹，是程序经过数学计算后的结果数据集。此定义与实际的弹道学有一些区别。 弹道模式：指用于描述弹道的各种配置方法。如下图： 由于弹道同时涉及 数学公式和代码定义 ，且许多插件都基于弹道移动，所以此文档需要全文反复学习。（多次简单过目该文档即可） 插件关系 弹道核心属于数学计算，服务于其他的核心或一般插件，关系如下： 弹道模式 相关 子插件 会根据自身特殊的情况， 提供部分模式的设置，但不一定会提供所有弹道模式的支持。 直角坐标模式 直角坐标模式通过 x速度 + y速度 控制轨迹。 时间、速度已知，路程未知。 X速度(vx)：正数向右，负数向左。单位 像素/帧。见 类型 - 速度 。 Y速度(vy)：正数向下，负数向上。单位 像素/帧。见 类型 - 速度 。 （注意，y速度正数向下，是反的。） 极坐标模式 极坐标模式通过 速度+方向 控制轨迹。 时间、速度已知，路程未知。 速度(v)：正数沿着方向移动，负数反向移动。单位 像素/帧。见 类型 - 速度 。 方向(θ)：0朝向右，90朝下，-90朝上，顺时针规律。单位 角度。见 类型 - 方向 。 （可以写超过360的数。390度与30度的方向一样。） 轨道锚点模式 轨道锚点模式中，轨迹是固定的，通过速度，来确定在轨迹中的具体位置。 简单来说，就好比铺火车轨道，无论火车如何加速减速，都一定按照固定轨道到移动，不可能脱轨移动。 设置锚点 = 铺火车轨道 设置速度 = 火车速度变化 速度(v)：正数沿着轨道移动，不支持负数。单位 像素/帧。见 类型 - 速度 。 轨道锚点：绘制固定的锚点列表。单位像素。见 类型 - 轨道锚点 。 （只适合单个粒子移动，多个粒子移动效果不明显。） 两点式 两点式通过 固定模式+目标点 控制轨迹。 时间、路程已知，速度未知。 起始点：粒子移动前所在的位置。 目标点：分为绝对坐标与相对坐标，用于计算当前物体到目标物体的路程。 固定模式：由于时间和路程是固定量，只有速度是可控制变量。 根据速度的不同变化方式，可分成多种模式。见 类型 - 两点式 。 （只适合 单个对象 移动，多个对象 会重叠。） 参数类型 类型 - 速度 1）初速度 公式参数名：p.v0 。 速度1，表示 1像素/帧。 速度1.5，表示 1.5像素/帧。 速度可以为负数，表示反方向移动。 只有初速度时，表示匀速运动，可见：公式：只初速度。 2）随机波动量 公式参数名：p.wave 。 在粒子的速度的基础上，添加/减少的随机速度量。 比如，初速度为10，波动量为8，那么速度为：6~14之间。（10-4 ~ 10+4） 初速度+波动量 仍然为匀速运动，可见：公式：初速度+波动量。 3）加速度 公式参数名：p.a 。 粒子在运动过程中，速度逐渐改变的加速度值。 极坐标模式中：无论加速度如何变化，都不会影响运动方向。 直角坐标模式中：如果vy的加速度化和vx的加速度不一样，那么就会间接改变这个粒子的实际方向。比如，vx匀速+vy匀加速 = 抛物线。 4）速度最大/最小值 公式参数名：p.vMax p.vMin 。 设置限制后，无论速度如何变化，都会保持在最大速度和最小速度之内。 比如，一个不断减速的粒子，如果设置了最小速度0，则会停下来。否则粒子速度将会越来越小，变成负数，朝反方向开始移动。 5）路程计算公式 见后面的章节 路程计算公式 。 类型 - 方向 1）方向单位 主要方向单位为 角度 ，部分设置里面可能会使用弧度，360（角度）= 2π（弧度）。 如果特殊情况要求输入弧度时，可用3.14代替π。 2）四周扩散 四周扩散，即以中心点为基准，方向随机。 3）扇形范围 图中的朝向的角度为0，90度朝下，-90朝上，顺时针规则。 扇形角度为360时 = 四周扩散 4）方向计算公式 见后面的章节 方向计算公式 。 类型 - 轨道锚点 1）锚点列表 这里的轨道，可以通过弹道绘制器绘制出来，从而形成锚点列表。 子弹会根据锚点列表描绘的轨迹，依次进行轨道移动。 2）限时问题 注意，虽然粒子会按照指定的轨道移动，但是粒子 不一定会 走完全部轨道。 粒子的移动时间结束后，粒子会 停在 当前的位置。 1800帧 = 30秒（可以设置时间长一点，但是不要超过5000，会影响计算速度） 类型 - 两点式 两点式被 窗口、按钮组、图片 等相关插件频繁使用。 其最大的特点就是时间固定，并且最终时间一定会到达终止点。 1) 不移动 不移动指：指定的对象仍然会保持在起始点，永远 不会 到目标点。 不移动就是字面意思上的真的不移动。 窗口设置不移动时，通常偏移的 坐标 也需要置零。 因为如果没置零，会造成窗口长期停滞在 起始点 ，而不是在原位置。 2) 瞬间移动 瞬间移动顾名思义，瞬间移动到目标点。 （设置匀速移动，移动时间为1帧，与瞬间移动的原理是一样的。） 注意，插件指令执行 并不能立刻到达目标点，需要1帧的准备时间。 因此，执行瞬间移动的指令时，需要等待一帧。 3) 匀速移动 匀速移动根据 已知路径 除以 已知时间 得到速度。 4) 增减速移动 增减速移动中，路程被分为两个部分，前半部分是匀加速，后半部分是匀减速。 5) 弹性移动 弹性移动实际上就是是有初速度的匀减速移动，只是这种移动看起来更加自然而已。 6) 抛物线移动 抛物线移动会额外受到 初速度+方向 的影响，但最终一定会到达目标点。 如果方向与目标点一致，则效果为匀加速运动。 注意，粒子到达终止点后，终止点的速度绝对值一般都会比起始点的速度绝对值大。也就是说，如果持续进行抛物线移动，那么甩动的轨迹会越来越大。 数学公式 公式关系 具体公式脚本，你可以直接打开Core_Of_Ballistics.js 脚本进行查看学习哦。 可用变量与常量 变量：是指在游戏中，随时变化的量。 可以简单理解为：插件指令调用，设置的数字，就是变量。 常量：是指在游戏编辑器中，配置的固定的量，在游戏中不会变化。 可以简单理解为：打开插件配置，然后你在配置里面设置了一个固定的值。 速度、加速度等设定，都是通过路程计算公式配置的。 无论是极坐标模式，还是直角坐标模式，路程都决定了粒子最终所在的位置。 直接写数字常量 直接写数字常量：如果你使用的是公式，那么可以直接写数字代替常量，因为常量只是一个可扩展编辑的量，在游戏中不会变化。 举个例子，速度公式如下： var result = p.v0 * p.time; //（速度x时间） return result; 如果你在配置中写了初速度:5.0， 那么与你写的下面的自定义公式是完全一样的： var result = 5 * p.time; //（速度x时间） return result; 注意，p.time不能写成数字，因为在游戏中是实时变化的量。 如果公式中没有变量，那么这个粒子将持续固定在一个具体的位置。 路程计算公式 可用变量与常量 变量：是指在游戏中，随时变化的量。 常量：是指在游戏编辑器中，配置的固定的量，在游戏中不会变化。 变量名 中文名 取值范围 描述 p.index 粒子序号值 整数，0 至 p.num-1值 粒子定义的Id序号值。 p.time 时间值 整数，0 至 游戏中设定的时间值 移动的时间范围值。 p.ran 随机值 小数，0.0 至 1.0 范围随机值 插件内部的可控随机值，不建议用Math.random()。 p.num 粒子数量 整数，游戏中设定的粒子数量 游戏中设定的粒子数量。 常量名 中文名 说明 p.v0 初速度 无特殊规定。 p.wave 波动量 一般该常量与随机值一起使用。 p.a 加速度 无特殊规定。 p.vMax 最大速度 无特殊规定。 p.vMin 最小速度 无特殊规定。 公式关系说明可以看前面章节：公式关系 。 公式：只初速度 众所周知，r = v*t，路程=时间*速度。 匀速运动的情况最简单，长方形面积就是路程。 只初速度的v-t图 公式如下： 用到了 变量 p.time，常量 p.v0 。 var result = p.v0 * p.time; //（速度x时间） return result; 公式：初速度+波动量 波动量是指，初速度有一定的随机性，可以在上下进行浮动。 简单来说，就是在初速度公式上，额外增加一个波动变化的量。 在出现大量粒子时，通过波动量能够有效让他们散开。 初速度+波动量的v-t图 公式如下： 用到了 变量 p.time/p.ran，常量 p.v0/p.wave 。 var v_ran = p.wave * (p.ran - 0.5); //（根据波动量，算出波动速度） var result = (p.v0 + v_ran) * p.time; //（随机速度x时间） return result; 需要注意的是，如果vRan波动量比v0初速度还大，那么就会出现速度为负值的情况。 速度为负，则会朝 相反 的方向移动。 初速度+波动量的v-t图 公式：初速度+波动量+加速度 匀加速运动的公式为：r=vt+½at²，也就是图中的长方形和三角形的和。 v0为初速度，a为加速度，time为时间。 则图中的v1=v0+a*time。 则公式为： v0*time+0.5*a*time*time 初速度+波动量+加速度的v-t图 公式如下： 用到了 变量 p.time/p.ran，常量 p.v0/p.wave/p.a 。 var v_ran = p.wave * (p.ran - 0.5); //（根据波动量，算出波动速度） var result = (p.v0 + v_ran) * p.time + 0.5 * p.a *p.time*p.time; return result; （如果你熟悉js的一些数学函数用法，也可以使用 Math.pow(time,2) 表示时间的平方 ） 如果出现 速度v0 为负数情况，公式依然成立。 你将会看到一个粒子逐渐停下，然后朝反方向持续加速的过程。 初速度+波动量+加速度的v-t图 公式：初速度+波动量+加速度+最大最小 最大速度和最小速度是一个十分特殊的情况。 它会将速度变化分成多段。 如果速度超出了最大速度，那么就减去vMax多出的面积。 如果速度低于了最小速度，那么就加上vMin多出的面积。 最大速度切割v-t图 最小速度切割v-t图 最大最小速度组合切割的v-t图 v0为初速度，a为加速度，time为时间，vMax为最大速度，vMin为最小速度。 公式如下： 用到了 变量 p.time/p.ran，常量 p.v0/p.wave/p.a/p.vMax/p.vMin 。 var v_ran = p.wave * (p.ran - 0.5); //（根据波动量，算出波动速度） // > 加速度公式 var v1 = (p.v0 + v_ran) + p.a * p.time; var d = (p.v0 + v_ran)*p.time + 0.5 * p.a *p.time*p.time; var result = d; // > 分段函数（超过上限/下限，将减去多出的路程值） if( v1 >= p.vMax ){ var m_v = v1 - p.vMax; var m_t = (v1 - p.vMax) / p.a; result = d - m_v*m_t + 0.5 * p.a *m_t*m_t; } if( v1 \\ 自定义公式 当你使用自定义公式时，之前提及的常量（见可用变量与常量）都可以加入设计， 你甚至可以作为其他特殊的参数进行使用。 举个例子，你写了下面的公式： var result = p.v0 * p.v0 * p.time * p.id; return result; 公式中用到了 p.v0常量，那么， 配置类型为：路程计算公式，配置初速度为：5.0 在公式中，将会等价于： var result = 5.0 * 5.0 * p.time * p.id 你所写自定义公式的 p.v0 真实含义 可能并不表示“初速度”的意思， 但是该参数的确可以作为一个配置值来使用。 注意，设计公式时，常量是最后再考虑加的参数，设计公式时，不要把变量和常量放一起写，会把自己绕晕。 方向计算公式 可用变量与常量 变量：是指在游戏中，随时变化的量。 常量：是指在游戏编辑器中，配置的固定的量，在游戏中不会变化。 变量名 中文名 取值范围 描述 p.index 粒子序号值 整数，0 至 p.num-1值 粒子定义的Id序号值。 p.time 时间值 整数，0 至 游戏中设定的时间值 移动的时间范围值。 p.ran 随机值 小数，0.0 至 1.0 范围随机值 插件内部的可控随机值，不建议用Math.random()。 p.num 粒子数量 整数，游戏中设定的粒子数量 游戏中设定的粒子数量。 常量名 中文名 描述 p.d0 固定方向 无特殊规定。 p.sFace 扇形朝向 无特殊规定。 p.sDegree 扇形范围 无特殊规定。 公式关系说明可以看前面章节：公式关系 。 公式：固定方向 指定一个方向，就是一个方向，不会改变。 由于没有改变的成分，所以只用到了常量。 注意，如果你同时发射10个子弹，这10个子弹的 方向 都会重叠在一起，如果其速度配置也没有随机波动量散开，那么将只看到1个子弹。 公式如下： 用到了 变量 无， 常量 p.d0 。 var result = p.d0; //（固定方向） return result; 公式：四周扩散 1) 四周扩散（线性） 将一整个圈，按粒子数量平均划分方向值。 公式如下： 用到了 变量 p.index/p.num，常量 p.d0 。 var result = p.d0 + 360 * p.index / p.num; return result; //（在一个圆圈里，放入固定数量的粒子） 2) 四周扩散（随机） 将一整个圈，随机划分方向值。 公式如下： 用到了 变量 p.ran，常量 p.d0。 var result = p.d0 + 360 * p.ran; return result; 3) 四周扩散（抖动） 抖动功能，是在固定随机方向的基础上，再进行一次随机偏移。 需要注意的是，由于Math.random 的值不可控，这会造成 重复发射/反向弹道 都不能完美复现原有的轨迹，所以尽量少用。 （这个功能其实挺鸡肋，也不知道在什么情况下用的上） 公式如下： 用到了 变量 p.ran，常量 p.d0。 var result = p.d0 + 360 * p.ran + 30 * Math.random(); return result; 公式：扇形范围方向 1) 扇形范围方向（线性） 扇形范围，是指以朝向为基准，向两侧撑开的扇形结构。 注意，扇形范围方向，与 p.d0 固定方向的参数没有任何关系。 线性的扇形范围需要区分 只一个粒子 和 有两个或以上 的粒子情况。 单独一个粒子时，发射的朝向就是 扇形朝向 。 公式如下： 用到了 变量 p.index/p.num，常量 p.sFace/p.sDegree 。 var result = p.sFace; if( p.num > 1 ){ result = p.sFace + p.sDegree * p.index / (p.num - 1) - p.sDegree/2; }else{ result = p.sFace; } return result; 2) 扇形范围方向（随机） 随机的扇形范围，就不需要考虑粒子数量问题了。 公式如下： 用到了 变量 p.ran，常量 p.sFace/p.sDegree 。 var result = p.sFace + p.sDegree * (p.ran - 0.5); //（根据p.sDegree，算出波动范围方向，与朝向相加即可） return result; 自定义公式 当你使用自定义公式时，之前提及的常量（见可用变量与常量）都可以加入设计， 你甚至可以作为其他特殊的参数进行使用。 举个例子，你写了下面的公式： var result = p.d0 * p.d0 * p.time * p.id; return result; 公式中用到了 p.d0常量，那么， 配置类型为：方向计算公式，配置固定方向为：0.8 在公式中，将会等价于： var result = 0.8 * 0.8 * p.time * p.id 你所写自定义公式的 p.d0 真实含义 可能并不表示“固定方向”的意思， 但是该参数的确可以作为一个配置值来使用。 注意，设计公式时，常量是最后再考虑加的参数，设计公式时，不要把变量和常量放一起写，会把自己绕晕。 组合公式效果 抛物线运动 抛物线是最常用的效果了。 运动轨迹分为x轴和y轴两个方向。（极坐标也可以表示，但是公式比较复杂。） 原理不难理解，举个例子：平抛运动（高一物理） 下图中，一个球向一个方向匀速抛出，但是球本身受到 重力加速度 的影响，可以形成一个弧线轨迹。 也就是说，x轴匀速，y轴加速运动，就可以形成抛物线。 由于平抛运动的y轴初速度是0，所以是一个一直向下的抛物线。 如果y轴初速度是负数，那么可以形成先向上，再向下的抛物线轨迹。 比如 子插件 地图UI-漂浮参数数字 配置抛物线弹道后，实现的喷泉抛物线。 间隔改变方向运动 逆时针圆周运动 "},"3.系统/3.5.关于按钮组核心.html":{"url":"3.系统/3.5.关于按钮组核心.html","title":"3.5.关于按钮组核心","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 插件介绍 名词索引 插件关系 思维导图 主体 按钮组中心 起点 资源图片 默认按钮贴图 指定按钮贴图 按钮名称 排列 排列方式 排列与流线 名称块 定义 选中的按钮 选中与未选中 线性变化 周期变化 指针 菜单指针 激活 激活流程 激活出列 输入设备 鼠标 键盘与排列 概述 插件介绍 按钮组的有许多作用范围，菜单界面、战斗界面、地图界面都可以作用到： ◆Drill_CoreOfSelectableButton 系统 - 按钮组核心 以下是按钮组的子插件： ◆Drill_SceneMain 面板 - 全自定义主菜单面板 ◆Drill_SceneSelfplateI 面板 - 全自定义信息面板I 核心只对按钮组的各个部件进行详细说明，如果你想找”从零开始设计”教程，去看看子插件相关的文档说明。 名词索引 以下你可以按住ctrl键点击下面的词，可以直接定位到想了解的名词： 主体 按钮贴图 按钮名称 相对坐标起点 统一坐标起点 排列 直线排列 环形排列 矩阵排列 固定离散排列 名称块 名称块 选中的按钮 线性变化 周期变化 出列 激活 激活流程 激活出列 插件关系 按钮组核心的插件关系如下图。 思维导图 按钮组结构的思维导图如下：（调整一下word右下角的缩放率，可以看清小字） 主体 按钮组中心 如果你对按钮组的位置规划存在疑问，你可以开启DEBUG，显示规划线： 按钮组核心中所有坐标设置都以按钮组(0,0)中心位置为基准。 子插件可以设置按钮组的整体位置，对整体进行位移。 (不同的排列方式下围绕中心点排列的方式不一样，具体可以看看 排列方式 。) 起点 起点是指 按钮最初出现的位置，进入菜单后，按钮会从起点回到原位置。 分为相对坐标的起点与统一坐标的起点。 （相对起点 与 统一起点 是很久以前提的概念，在旧版本的文档中有提及。由于mog插件写死了结构，一直实现不了，现在终于推翻了。） 1）相对坐标起点 所有按钮从相对的起点出发，回到自己的位置。 2）统一坐标起点 所有按钮从同一个起点出发，回到自己的位置。 3）不移动直接显现 设置起点的坐标类型为 相对坐标 ，起点为(0,0)即可。 资源图片 默认按钮贴图 注意，核心本体并不配置贴图资源，贴图资源都在子插件中配置。 这里以子插件 全自定义信息面板I插件 为例子。 信息面板I有按钮组 中心位置 配置（对应按钮组中心）、按钮组样式（对应核心配置的样式id）、以及按钮贴图。 按钮贴图配置后，所有按钮将会用同一个背景图片。 指定按钮贴图 注意，核心本体并不配置贴图资源，贴图资源都在子插件中配置。 按钮组核心必须依赖一个有 选项的窗口，通过选项窗口获取到对应的选项。 每个选项都对应一个按钮贴图。 对应模式是由 子插件 固定的，不能改。 1）顺序对应 部分子插件使用的是顺序对应，即根据序号一一对应。 以 信息面板I为例子，效果为：第n个内容选项，对应第n个按钮。 2）按钮关键字对应 部分子插件采用按钮关键字进行绑定，与顺序无关。 其中 全自定义主菜单插件 就是基于按钮关键字 对应的，（因为按钮随时会增减，并且都可能来自不同插件）具体可以去看看”菜单关键字.docx”。 下图为：道具按钮 通过Button_item关键字，对应到主菜单的面板中。 按钮名称 按钮名称即写在按钮上面的名称。 注意，按钮名称与名称块是两个不同的东西。 下图中，红色框内的单独漂浮名称是名称块，黄色框内与按钮一起的是按钮名称。 你可以把名称写在按钮资源图片中，也可以使用空的按钮背景，然后显示按钮名称，按钮名称支持各类特殊字符。 排列 排列方式 按钮组可以完全自定义排列方式，也可以使用下面规律公式的排列。 1）直线排列 直线排列有三个参数：直线间距、直线W间距、直线旋转角度。 其中W间距是针对偶数按钮的垂直相对间距。 > 间距30，W间距0，角度0的情况如下： > 间距30，W间距20，角度0的情况如下： > 间距30，W间距20，角度45的情况如下： 当然，如果按钮数量很多，很可能会挤出到游戏之外，你可以限制按钮的最大长度，使得超过最大长度后，强制挤在一起，而不再延伸。 2）环形排列 环形排列有三个参数：环形半径、环形起始角、环形终止角。 当环形起始角与终止角 相等 或 相差360度 时，相当于形成了一个闭环，则所有按钮均匀平分圆。按钮数量越多，平分越细。比如下面例子： （黄色为起始角，红色为终止角，0度向右，90度向下，180向左，270向上） >半径145，起始角270，终止角270的情况如下： >半径145，起始角270，终止角90的情况如下： 3）矩阵排列 矩阵排列有三个参数：矩阵列数、矩阵列宽、矩阵行高。 由于按钮组的前身就是窗口的矩阵排列，这里相当于保持窗口的原排布方式，进行类似的按钮变换。 >列数5，列宽48，行高48的情况如下： >列数3，列宽48，行高48的情况如下： 4）固定离散排列 除了上述公式化的排列方式，你还可以自定义设置所有坐标点。只不过，需要从1到n按顺序填写每个坐标点，如果按钮序号>n，则按钮默认处于0,0位置（按钮组的中心点）。 排列与流线 开发中，待续。 名称块 定义 名称块：名称块是指 当前选中 的选项名称贴图。与按钮贴图不同，是独立显示的结构。 图中黄色方框内的为名称块。你可以放在其他位置，不一定必须在中心。 选中的按钮 选中与未选中 按钮变化效果：按钮组中，所有按钮的变化效果都是独立的，插件会对当前选中的按钮进行透明度变化、摇晃效果、缩放效果、浮动效果、出列等变化。 当选中的按钮失去选中焦点后，变化效果并不会立即消失，会有一小段恢复过程。 根据恢复过程的不同，分为两种变化：线性变化与周期变化。 线性变化 线性变化：是指A状态变化到B状态后将停止，失去焦点后才回到A状态的变化。 1）出列 这里的 出列 和 激活状态的出列 不同，按钮选中时，会在相对自己的位置，偏移多出一定的位置。 这个效果在环形排列中并不常用，在矩阵排列（抽卡弹出）或直线排列（凸出的选项）中比较常见。具体需要根据你的情况来设计。 2）透明度变化 透明度变化原理为： A状态为”未选中按钮透明度”，B状态为透明度255值。 通过对选中的按钮线性变化透明度，来实现按钮高亮。 如果未选中按钮的透明度被设置为255，则高亮效果将会失效。 周期变化 周期变化：是指ABACA这样循环变化的状态，失去焦点后，变化会自动找到一个A状态的落脚点，恢复到A状态。 闪烁效果周期变化的参数是透明度，若开启了闪烁效果，线性透明度变化会被覆盖。 摇晃效果周期变化的参数是旋转角度。 缩放效果周期变化的参数是缩放x和缩放y。 浮动效果周期变化的参数是xy偏移值。 这些参数都可以与其他效果完全叠加，但是注意，效果如果全部叠加，反而会非常难看，所以你需要根据实际情况进行选择。 指针 菜单指针 指针功能需要下面的插件支持，才能具备功能。 ◆Drill_MenuCursor 主菜单 - 多样式菜单指针 从本质上说，指针就是一个贴图。 可以是圆环，可以是指向标，可以是大外框，还可以配置成gif。 考虑到指针的多变性，菜单指针中你可以自定义多个不同的指针样式。 具体可以去看看”关于指针与边框.docx”。 由于按钮组没有矩形区域框，所以不能支持 菜单选项边框 和 菜单滚动条 。 激活 激活流程 按钮组的本质，是一个有选项的窗口，窗口的先后顺序，将会影响界面的流程，但是总体是一样的。 激活流程分为：激活前状态、激活状态、激活后状态 三种。 处于 激活状态 时，按钮才可以进行选择。 处于 激活后状态 时，选中的按钮可以单独显示并出列。 激活出列 由于激活的条件比较特殊，按钮核心只有特定的子插件才会有相关配置。 以主菜单为例，在 菜单选项按钮组 处于 激活后状态 时，选中的按钮会跑到指定偏移的位置。 值得一提的是，按钮变化效果、 激活出列、移动动画 三者是相互独立的变化系统，三者是叠加在一起的。 激活出列时，移动动画的变化会收起，使得最终按钮的移动轨道并不是直线。 输入设备 鼠标 1）触发范围 按钮的触发范围，是以配置的资源贴图的范围而定的。 比如，如果你开启了”按钮接近后自动选中”功能，你会发现按钮接近激活的范围是矩形的区域。这个矩形区域就是资源图片的高宽。 2）触发顺序 如果多个按钮相互挤在一起，点击相交的位置，则会触发配置id最小的按钮。 按钮被点击后，如果指定的按钮没有被选中，那么将会选中该按钮。 按钮在选中状态被点击，才会进入执行按钮的功能。 3）滚轮控制 鼠标滚轮控制开启后，滚动鼠标滚轮即可切换选中的按钮。 切换间隔用于控制滚轮切换的速度，防止滚动的太快。 键盘与排列 注意按钮组的排列方式，你需要根据排列实际情况，配置合适的键盘模式。 比如90度朝下的直线排列，使用的是 上下切换 键盘模式。 而270度朝上的直线排列，使用的是 反向上下切换 键盘模式。 "},"3.系统/3.6.关于输入设备核心.html":{"url":"3.系统/3.6.关于输入设备核心.html","title":"3.6.关于输入设备核心","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 相关插件 名词索引 键盘与手柄 定义 什么是逻辑按键 控制方法 特殊控制 修改按键映射 鼠标与触屏 定义 控制方法 概述 相关插件 输入设备的相关插件如下： ◆Drill_CoreOfInput 系统 - 输入设备核心 ◆Drill_OperateHud 互动 - 鼠标辅助操作面板 ◆Drill_OperateKeys 互动 - 键盘手柄按键修改器 目前输入设备分为四种：键盘、手柄、鼠标、触屏。 官网有关于按键的部分说明：（看看就好，介绍没那么详细） http://help.rpgmakermv.cn/#page/01_06.html!cn 名词索引 以下你可以按住ctrl键点击下面的词，可以直接定位到想了解的名词： 键盘与手柄 物理按键 逻辑按键 按键映射 修改按键映射 功能键 基本键 扩展键 鼠标与触屏 鼠标按键 鼠标悬停 鼠标滚轮 单指轻触 双指轻触 键盘与手柄 定义 物理按键：指真实世界键盘上存在的按键，比如z,x,c,v键等。 逻辑按键：指游戏中用于划分特定功能的按键，比如确定键,取消键,跳跃键等。 按键映射：是指 物理按键 映射到 逻辑按键 的过程。 一个正常的按键流程如下： 游戏功能中也可能会直接指定 某个物理按键 按下后才能生效，这样的游戏功能，无法支持键盘改键。 什么是逻辑按键 这里几个逻辑按键的例子： 1）任意键 任意键 在键盘上并不是真实存在的，你按一个“a”键，就能够触发 任意键。 （在电脑刚刚普及的时候，曾有大量用户打电话给厂商问任意键在键盘上哪个地方……） 但是，游戏中的“任意键”真的就是任意的键了吗？我按一下“ctrl键”，你看看那个游戏会不会有反应。 因此，任意键是一个我们在口头上用于表示一个功能的按键，而这些按键并不唯一。 具体还与游戏设置有关系。 2）确定键 接着，什么是确定键？ 同样的道理，”z”键，是确定键；按”回车”，也是确定键。 多个真实物理的按键，可以表示同样的 确定键，可见，确定键也不是唯一的按键。 这种多个 物理按键 表示同一个 逻辑按键 的过程，称为“按键映射”。 你可以通过插件修改 确定键 的按键映射，具体可以看看后面章节： 修改按键映射。 控制方法 1）rmmv默认 Rmmv默认的 物理按键 与 逻辑按键 关系如下： 功能 键盘 手柄*1 逻辑按键 移动 方向键 上， numpad 8 键 摇杆 上， 方向键 上 上（'up'） 移动 方向键 下， numpad 2键 摇杆 下， 方向键 下 下（'down'） 移动 方向键 左， numpad 4键 摇杆 左， 方向键 左 左（'left'） 移动 方向键 右， numpad 6键 摇杆 右， 方向键 右 右（'right'） 确定 enter回车， 空格， z键 A键 确定键（'ok'） 取消 Esc键， Insert键， x键， numpad 0 键 B键 取消键（'cancel'） 加速 shift键 X键 加速键（'shift'） 菜单 Esc键， Insert键， x键， numpad 0 键 Y键 菜单键（'menu'） 上一页 PgUp键， q键 LB键 上一页（'pageup'） 下一页 PgDn键， w键 RB键 下一页（'pagedown'） 辅助tab Tab键 无 辅助Tab键（'tab'） 测试中Debug F9键 无 游戏测试Debug键（'debug'） 测试中穿墙 Ctrl键， Alt键 无 游戏测试穿墙键（'control'） 1.辅助tab键在rmmv本体中并没有被使用。相关子插件可能会用到该插件。 2.测试Debug键，是指只在测试中生效的按键，游戏部署后将不再有效。 2）Drill插件默认 Drill插件 默认的 物理按键 与 逻辑按键 关系如下： 功能 键盘 手柄*1 逻辑按键 跳跃 q键 LB键 跳跃键（'jump'） 原地转向 w键 功能键 + 方向键 原地转向键（'rotate'） 举起花盆 z键 A键 举起花盆键（'pick'） 投掷花盆 z键 A键 举起花盆键（'throw'） 放置炸弹 c键 功能键 + X键 放置炸弹键（'bomb'） 特殊控制 此部分特殊控制是 软件程序内部 的控制功能，无法修改。 功能 键盘 手柄*1 逻辑按键 FPS开关 F2键 无 无 (浏览器) 拉伸开关 F3键 无 无 (浏览器) 全屏模式 F4键 无 无 重启游戏 F5键 无 无 测试中开发者模式 F8键 无 无 修改按键映射 你需要通过下面的插件 ，修改上表中的 按键映射。 ◆Drill_OperateKeys 互动 - 键盘手柄按键修改器 按键修改器中引入了下列几个新的概念规则： 手柄的功能键：因为手柄的键位少，所以为了支持更多功能，使用了 功能键+其它键 的按键方式。 基本键：基本键属于 逻辑按键，特点是 相互 不能对应重复的 物理按键，否则可能导致按键失效。 比如 确定键和取消键，不能用同一个 物理按键（比如g键）表示，因为你按g键后，系统既会执行确定功能，又会执行取消功能，相互冲突。 扩展键：扩展键属于 逻辑按键，特点是可以对应重复的物理按键。 比如 举起花盆和投掷花盆 ，可以用同一个键位映射。 鼠标与触屏 定义 鼠标按键：指鼠标的按键，分为三种： 鼠标左键、鼠标中键（滚轮）、鼠标右键。 鼠标悬停：指鼠标指针移动到指定的范围内，触发按钮的功能。 鼠标滚轮：指鼠标滚轮上滚和下滚的功能。 注意，由于鼠标的功能按键太少，所以不存在逻辑按键，更不能实现改键功能。 单指轻触：指用一根手指接触屏幕。 双指轻触：指用两根以上的手指接触屏幕。 注意，浏览器中对于 触屏滑动、双指外滑内滑 都提供有相应的接口，但是由于本身游戏中对于触屏的扩展性并不高。（drill插件也很少考虑手机的功能支持）因此，这里只提及，并不深入研究。 控制方法 1）rmmv默认 功能 鼠标 触屏 移动 左键点击目的地 轻触目的地 确定 左键点击目标 轻触目标 取消 右键点击 双指轻触 加速 移动到目的地时自动加速 移动到目的地时自动加速 菜单 右键点击 双指轻触 上一页 左键点击选项框滚动小箭头 轻触选项框滚动小箭头 下一页 左键点击选项框滚动小箭头 轻触选项框滚动小箭头 页面滚动 （特殊） 滚轮滚动 无 2）地图界面点击 地图界面点击时，可以使用 “互动-鼠标辅助操作面板” 插件进行辅助。 具体去看看 “10.互动 > 关于鼠标辅助操作面板.docx”。 3）菜单数量面板 在用到菜单窗口中，输入数字的功能时，会自动弹出菜单数量面板： 功能 按钮 鼠标 触屏 +1数量 点击目标 轻触目标 -1数量 点击目标 轻触目标 +10数量 点击目标 轻触目标 -10数量 点击目标 轻触目标 确定 点击目标 轻触目标 "},"3.系统/3.9.方块粉碎大家族.html":{"url":"3.系统/3.9.方块粉碎大家族.html","title":"3.9.方块粉碎大家族","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 插件介绍 插件关系 定义 方块粉碎 弹道 自定义粉碎 一般粉碎 比例粉碎 指令时差（对话框粉碎） 其他说明 性能影响 概述 插件介绍 方块粉碎的作用范围比较广，它由基于弹道的方块粉碎核心，派生出许多子插件： ◆Drill_CoreOfBallistics 系统 - 弹道核心 ◆Drill_CoreOfShatterEffect 系统 - 方块粉碎核心 以下是方块粉碎的子插件： ◆Drill_BattleShatterEffect 战斗 - 方块粉碎效果 ◆Drill_LayerShatterEffect 地图 - 方块粉碎效果 ◆Drill_EventShatterEffect 行走图 - 方块粉碎效果 ◆Drill_PictureShatterEffect 图片 - 方块粉碎效果 ◆Drill_DialogShatterEffect 对话框 - 方块粉碎效果 插件关系 插件的从属关系如下图： 需要注意的是，虽然都属于方块粉碎家族，但是插件里面的插件指令/注释，可能指令和参数的格式有很大区别，注意区分。 定义 方块粉碎 方块粉碎，是在资源图片的基础上，对资源图片进行额外切割分片处理的模块。 切割的范围为资源图片的大小，下图中为3行4列的切割情况，一共分成了12等分。由于图中第9等分为全透明的图片，所以看不出来。 方块粉碎一般为动态效果，不会持续非常长的时间。不过，部分子插件可以支持碎片长时间滞留在界面中。 弹道 弹道是描述一群粒子/碎片/子弹运动的轨迹。 具体弹道的内容，去看看”关于弹道.docx”。 方块粉碎后，由于被切成了许多片，每块碎片都可以有不同的弹道轨迹，从而形成碎片四处散落的效果。 由于弹道具有回溯反转的功能，你可以使用插件指令倒放粉碎效果。 自定义粉碎 一般粉碎 基于弹道的相关知识，你完全可以自定义粉碎效果，具体属性去看看”关于弹道.docx”。 其中，切割的行数和列数需要你根据实际情况来考虑，小图切割的比较散，大图切割的比较密。你也可以行数10，列数1，那么切割出来的为10个横条。 设计自定义粉碎时，你需要确保随机波动量足够大，使得方块粉碎能够比较均匀地散开，不然所有碎片挤在一起，看不出粉碎的效果。 比例粉碎 一般粉碎中，除了波动量设置，每块碎片的速度都几乎一样。 比如线性粉碎中，你能够清晰地看到一个圆向外扩散的样子。因为所有碎片的速度都几乎一样。 而比例粉碎，最外面碎片的速度最快，里面的速度较慢。通过设置 \"碎片速度是否分比例\" 可以使得碎片里外的速度不一样。 （波动量也可以让速度不一样，但是每块碎片的速度都会随机快慢。而比例速度，是里面的碎片一定慢，外面的碎片一定快。） 指令时差（对话框粉碎） 指令时差是对话框粉碎中一个特殊的情况。 ◆Drill_DialogShatterEffect 对话框 - 方块粉碎效果 1) 阻塞时差 进入对话框时，对话框会阻塞事件指令，指令不会并行生效。 如果粉碎提前执行了，或者在对话框关闭后才执行，那么效果会非常差。 过早执行（文字还没输出来，就已经碎消失了） 过晚执行（对话已经结束且关闭了，才执行粉碎） 当然，如果执行的是 反转粉碎 ，设置延迟[0]是可以的。 2) 字符控制时差 对话时间是不稳定的，玩家如果不停地按确定键，或者消息核心的加速键，那么很有可能时间太短，粉碎根本就执行不到。你可以使用rmmv默认的等待字符，控制时差。 3) 选项与对话的时差 如果在第一个对话中，很短时间内就按了下一个对话，那么粉碎将会在第二个对话中执行。如果不按第一个对话，等第一个对话粉碎，第二个对话，就是已经粉碎且消失的状态，你将看不见任何内容。 所以，一般一个对话都会按照下面的方法，进行控制。确保每个对话，都能够看见，且隔一段时间粉碎掉。 当然，也有特殊情况，就是对话框和选择框必须贴在一起的情况，如果对话框和选择框中间有任何其他指令，则这两个框都不会同时出现。为了避免分开问题，你可以按照下面的方式写指令。 其他说明 性能影响 方块粉碎是性能消耗大户，因为他能够将1个贴图变成大量的新贴图碎片，并且每个贴图都有自己的弹道与运动。碎片的数量 = 切割矩阵列数 x 切割矩阵行数。 性能测试中并不能准确找到该插件的消耗量，只能通过update总消耗量相减来进行估算。所以误差会比较大。 具体性能数据你可以去看看”性能测试统计表(方块粉碎).xlsx”。 "}}